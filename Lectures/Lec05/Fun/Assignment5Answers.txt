
******************************************************************************************
let add x = let f y = x+y in f end
in add 2 5 end

val it: HigherFun.value = Int 7
******************************************************************************************
let add x = let f y = x+y in f end
in let addtwo = add 2
in addtwo 5 end
end

val it: HigherFun.value = Int 7
*******************************************************************************************
let add x = let f y = x+y in f end
in let addtwo = add 2
in let x = 77 in addtwo 5 end
end
end

val it: HigherFun.value = Int 7
*******************************************************************************************
let add x = let f y = x+y in f end
in add 2 end

val it: HigherFun.value =
  Closure
    ("f", "y", Prim ("+", Var "x", Var "y"),
     [("x", Int 2);
      ("add",
       Closure
         ("add", "x", Letfun ("f", "y", Prim ("+", Var "x", Var "y"), Var "f"),
          []))])

The reason it returns a Closure instead of a value, is because the function "add"
is applied to only one argument. So the result is a "Closure" waiting for a second argument.